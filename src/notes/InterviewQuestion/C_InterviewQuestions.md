---
title: c语言面试题
category:
  - 面试题
tag: 
  - 面试题集合
editLink: false   # 不允许编辑页面
date: 2023-03-24
---

### 1.变量的声明和定义的区别

```
变量定义：	为变量分配存储空间，还可以为变量指定初始值。程序中，变量有且只有一个定义
变量声明：	用于向程序表明变量的类型和名字。定义也是声明，当定义变量的时候我们声明了他的类型和名字。
			可以通过 extern 声明变量名而不定义它。extern 声明不是定义，它不分配存储空间。它只是告诉我们
			变量的定义在其他地方。程序中变量可以声明多次，但只能定义一次。
```

### 2.写出 bool、int、float、指针变量与 “零值”的比较的 if 语句

```
	if (flag)
		A;
	else
		B;
	
	if (0 != flag)
		A;
	else
		B;
	
	if (NULL != flag)
		A;
	else
		B;
	
	if (flag >= -NORM && flag <= NORM)
		A;
	else
		B;
/*特殊说明：float的表示方法的问题，float本身就是不精确的，精确度在小数点，float是 符号位+8bit的指数为+23bit的小数位组成的。那么这样就会有一个问题，如果数据中的
小数位超过了用来表示小数位的bit长度，就会有数据丢失，这个时候通常计算机会按照一定的规律进行转换得到一个非常接近的数值，例如13.765432有时候得到的值却是13.7654319。
这就是所谓的float类型不精确的原因。*/
```

### 3.sizeof 和 strlen 的区别

```
	sizeof：	是操作符	在编译的时候就计算出结果		参数可以是数据类型，也可以是变量	计算的是内存大小
	strlen：	是库函数	在程序运行的时候才计算出结果	参数是以'\0'结尾的字符串			计算的是字符串长度
```

### 4.static 关键字作用

```
C语言	static 关键字作用：
			1.修饰局部变量，相当于全局变量，延长了生命周期，直到程序运行结束后才释放。
			2.修饰全局变量，这个静态全局变量就只能在本文件中被访问，不能被其他文件访问，即使是 extern 外部声明也不行（全局变量可以被外部文件问）。
			3.修饰函数，这个函数就只能在本文件中被调用，外部文件不能被访问调用，外部文件的函数可以同名。
			static 修饰的局部变量存放在内存中的全局静态存储区
C++		static 关键字作用：
			1.修饰成员函数，静态成员之间可以相互访问，包括静态成员函数访问静态成员数据和访问静态成员函数。不能访问非静态成员函数和非静态成员数据。
				调用方法 类对象.静态成员函数  或者是类对象::静态成员函数。
				静态成员函数只属于类本身，随着类的加载而存在，不属于任何对象，是独立存在的。
			2.修饰成员数据，存储在全局静态区，静态数据成员定义时需要分配内存，所以无法在类声明中定义。不在类的声明中定义，是因为在类的声明中定义会
			导致每次类的初始化都包含该静态成员数据，与设计不符合。所有该类的实体对象（instance）都共用一个静态成员数据。
			3.protected 和 privated 修饰的静态函数无法被类外访问
```

### 5.malloc free 和 new delete 区别

```
C语言
	malloc、free 是库函数 	需要头文件支持	只是申请内存和释放内存，无法对自定义类型对象进行构造和析构
	malloc 	申请需要给定内存大小					成功返回 void * 需要强制转换		malloc 失败返回NULL	
	
new delete 是关键字		需要编译器支持	new 会先申请足够的内存（底层用malloc 实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针
				delete 会先调用类型的析构函数，然后释放内存（底层是用free 实现）
				new		申请无需给定内存大小 编译器会自行计算	成功返回 对象类型指针 无需强制转换	new 失败会抛出异常
```

### 6.写一个标准宏 MIN

```
#define MIN(a, b) ((a) <= (b) ? (a) : (b))
//要注意这个情况
	int b = 2;		//b = 1
	int * p = NULL;
	p = (int *) malloc(sizeof(int));
   	*p = 1;
   	qDebug() << MIN(++*p, b); 			// p = 3 b = 2; p的值变化了2次
									// p = 2 b = 1; p的值变化了1次
```

### 7.一个指针可以是 volatile 吗

```
可以的，指针和普通变量一样，有时也有变化程序的不可控性。防止编译优化，每次编译都重新读值
```

### 8.a 和 &a 的区别

```
	int A[5] = {1,2,3,4,5};
    int *P = (int *) (&A + 1);			//P 的地址 ：指向数组A的首地址 + sizeof(int) * 5

    qDebug() << A;			// 	0x44e9aff8d0
    qDebug() << P;			//	0x44e9aff8e4
    qDebug() << &A[0];		//	0x44e9aff8d0
    qDebug() << &A[4];		//	0x44e9aff8e0
    qDebug() << &A[5];		//	0x44e9aff8e4

    printf("%d  -- %d\n", *(A + 1), *(P - 1));		// 答案  -- 5
//	思考	int *P = (int *) (A + 1); 时 打印printf("%d  -- %d\n", *(A + 1), *(P - 1));是多少		2 -- 1
```

### 9.C语言内存分配

```
C语言	内存四区
			堆区	手动分配和释放 malloc/free 
			栈区	系统自动分配和释放，存放局部变量和函数参数
			全局区	程序运行时分配的内存
				细分：常量区 未初始化的全局数据区 初始化的全局数据区 静态变量也存放于此
			代码区	二进制代码存放的地方
堆和栈区别
		栈 自动分配和释放	速度快	效率高但无法控制			内存地址连续	系统设定好的最大容量，	 向低地址扩展
		堆 手动分配和释放	速度慢	效率低但能控制，容易产生碎片	内存地址不连续	系统用链表来存储空闲内存地址，大小受限于系统的有效虚拟内存			向高地址扩展
```

### 10.strcpy sprintf 和 memcpy 区别

```
	1.	操作对象不同：strcpy 是字符串，memcpy 可以是任意数据类型 sprintf 目的对象是字符串，但源对象可以任意基本数据类型
	2.	执行效率，memcpy 最高， strcpy 次之， sprintf 效率最低
	3.	strcpy : 字符串拷贝，不需要指定长度，它遇到 '\0' 结束符自动结束
		memcpy : 任意数据类型的拷贝，要指定长度，不会遇到 '\0' 结束符就自动结束
		sprintf: 用于拼接字符串和其他基本数据类型
```

### 11.设置地址为0x67a9的整形变量的值为0xaa66

```
	int *ptr;
	ptr = (int *)0x67a9;
	*ptr = 0xaa66;
```

