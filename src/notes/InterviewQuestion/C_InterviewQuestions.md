---
title: c语言面试题
category:
  - 面试题
tag: 
  - 面试题集合
editLink: false   # 不允许编辑页面
date: 2023-03-24
---

### 1.变量的声明和定义的区别

```
变量定义：	为变量分配存储空间，还可以为变量指定初始值。程序中，变量有且只有一个定义
变量声明：	用于向程序表明变量的类型和名字。定义也是声明，当定义变量的时候我们声明了他的类型和名字。
			可以通过 extern 声明变量名而不定义它。extern 声明不是定义，它不分配存储空间。它只是告诉我们
			变量的定义在其他地方。程序中变量可以声明多次，但只能定义一次。
```

### 2.写出 bool、int、float、指针变量与 “零值”的比较的 if 语句

```
	if (flag)
		A;
	else
		B;
	
	if (0 != flag)
		A;
	else
		B;
	
	if (NULL != flag)
		A;
	else
		B;
	
	if (flag >= -NORM && flag <= NORM)
		A;
	else
		B;
/*特殊说明：float的表示方法的问题，float本身就是不精确的，精确度在小数点，float是 符号位+8bit的指数为+23bit的小数位组成的。那么这样就会有一个问题，如果数据中的
小数位超过了用来表示小数位的bit长度，就会有数据丢失，这个时候通常计算机会按照一定的规律进行转换得到一个非常接近的数值，例如13.765432有时候得到的值却是13.7654319。
这就是所谓的float类型不精确的原因。*/
```

### 3.sizeof 和 strlen 的区别

```
	sizeof：	是操作符	在编译的时候就计算出结果		参数可以是数据类型，也可以是变量	计算的是内存大小
	strlen：	是库函数	在程序运行的时候才计算出结果	参数是以'\0'结尾的字符串			计算的是字符串长度
```

### 4.static 关键字作用

```
C语言	static 关键字作用：
			1.修饰局部变量，相当于全局变量，延长了生命周期，直到程序运行结束后才释放。
			2.修饰全局变量，这个静态全局变量就只能在本文件中被访问，不能被其他文件访问，即使是 extern 外部声明也不行（全局变量可以被外部文件问）。
			3.修饰函数，这个函数就只能在本文件中被调用，外部文件不能被访问调用，外部文件的函数可以同名。
			static 修饰的局部变量存放在内存中的全局静态存储区
C++		static 关键字作用：
			1.修饰成员函数，静态成员之间可以相互访问，包括静态成员函数访问静态成员数据和访问静态成员函数。不能访问非静态成员函数和非静态成员数据。
				调用方法 类对象.静态成员函数  或者是类对象::静态成员函数。
				静态成员函数只属于类本身，随着类的加载而存在，不属于任何对象，是独立存在的。
			2.修饰成员数据，存储在全局静态区，静态数据成员定义时需要分配内存，所以无法在类声明中定义。不在类的声明中定义，是因为在类的声明中定义会
			导致每次类的初始化都包含该静态成员数据，与设计不符合。所有该类的实体对象（instance）都共用一个静态成员数据。
			3.protected 和 privated 修饰的静态函数无法被类外访问
```

### 5.malloc free 和 new delete 区别

```
C语言
	malloc、free 是库函数 	需要头文件支持	只是申请内存和释放内存，无法对自定义类型对象进行构造和析构
	malloc 	申请需要给定内存大小					成功返回 void * 需要强制转换		malloc 失败返回NULL	
	
new delete 是关键字		需要编译器支持	new 会先申请足够的内存（底层用malloc 实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针
				delete 会先调用类型的析构函数，然后释放内存（底层是用free 实现）
				new		申请无需给定内存大小 编译器会自行计算	成功返回 对象类型指针 无需强制转换	new 失败会抛出异常
```

### 6.写一个标准宏 MIN

```
#define MIN(a, b) ((a) <= (b) ? (a) : (b))
//要注意这个情况
	int b = 2;		//b = 1
	int * p = NULL;
	p = (int *) malloc(sizeof(int));
   	*p = 1;
   	qDebug() << MIN(++*p, b); 			// p = 3 b = 2; p的值变化了2次
									// p = 2 b = 1; p的值变化了1次
```

### 7.一个指针可以是 volatile 吗

```
可以的，指针和普通变量一样，有时也有变化程序的不可控性。防止编译优化，每次编译都重新读值
```

### 8.a 和 &a 的区别

```
	int A[5] = {1,2,3,4,5};
    int *P = (int *) (&A + 1);			//P 的地址 ：指向数组A的首地址 + sizeof(int) * 5

    qDebug() << A;			// 	0x44e9aff8d0
    qDebug() << P;			//	0x44e9aff8e4
    qDebug() << &A[0];		//	0x44e9aff8d0
    qDebug() << &A[4];		//	0x44e9aff8e0
    qDebug() << &A[5];		//	0x44e9aff8e4

    printf("%d  -- %d\n", *(A + 1), *(P - 1));		// 答案  -- 5
//	思考	int *P = (int *) (A + 1); 时 打印printf("%d  -- %d\n", *(A + 1), *(P - 1));是多少		2 -- 1
```

### 9.C语言内存分配

```
C语言	内存四区
			堆区	手动分配和释放 malloc/free 
			栈区	系统自动分配和释放，存放局部变量和函数参数
			全局区	程序运行时分配的内存
				细分：常量区 未初始化的全局数据区 初始化的全局数据区 静态变量也存放于此
			代码区	二进制代码存放的地方
堆和栈区别
		栈 自动分配和释放	速度快	效率高但无法控制			内存地址连续	系统设定好的最大容量，	 向低地址扩展
		堆 手动分配和释放	速度慢	效率低但能控制，容易产生碎片	内存地址不连续	系统用链表来存储空闲内存地址，大小受限于系统的有效虚拟内存			向高地址扩展
```

### 10.strcpy sprintf 和 memcpy 区别

```
	1.	操作对象不同：strcpy 是字符串，memcpy 可以是任意数据类型 sprintf 目的对象是字符串，但源对象可以任意基本数据类型
	2.	执行效率，memcpy 最高， strcpy 次之， sprintf 效率最低
	3.	strcpy : 字符串拷贝，不需要指定长度，它遇到 '\0' 结束符自动结束
		memcpy : 任意数据类型的拷贝，要指定长度，不会遇到 '\0' 结束符就自动结束
		sprintf: 用于拼接字符串和其他基本数据类型
```

### 11.设置地址为0x67a9的整形变量的值为0xaa66

```
	int *ptr;
	ptr = (int *)0x67a9;
	*ptr = 0xaa66;
```

### 12.数组和链表的区别

```
存储形式不同：数组是一块连续的空间，声明时就要确定数组长度， 链表是一块可以不连续的空间，每个节点会保存相邻节点的指针。
数据查找：数组线性查找速度快，查找操作直接用偏移量就行。链表需要按顺序检索节点，效率较低。
数据插入或删除：链表可以快速删除和插入节点，而数据需要移动大量数据进行插入和删除。
越界问题：数组有越界行为，链表没有
数组便于查询，链表便于插入删除，数组长度固定，链表长度不固定
```

### 13.单链表翻转（原地算法）

```c
单链表反转：
void ReverseLinklist(struct Linklist *head)
{
	if (NULL = head || NULL == head->next || NULL == head->next->next)
		return ;
	struct Linklist *begin = head->next;
	struct Linklist *end = head->next->next;
	while(end != NULL)
	{
		begin->next = end->next;
		end->next = head->next;
		head->next = end;
		end = begin->next;
	}
}

```

### 14.指针和引用的区别

```
1.指针是一个变量，存储的是变量的地址，而引用是变量的别名
2.指针可以为空，引用不能为空，必须有实体
3.指针在初始化之后可以改变指向，而引用在初始化之后就不能改变
4.指针可以有多级，引用只有一级
5.sizeof 指针 得到的是指针的大小，而 sizeof 引用 得到的是引用所指向对象的大小
6.指针作为函数参数时，形参实际上是实参的一份拷贝，只是分别属于两个不同的指针变量，函数形参为引用时，能直接改变实参，他不拷贝实参，就是实参的一个别名
7.引用是类型安全，指针类型不安全（引用比指针多了类型检查）
```

### 15.&& 和 &  ,  || 和 | 有什么区别

```
& 和 | 是对操作数进行求值运算，&& 和 || 是判断逻辑关系的
&& 在判断左操作数失败时就不会判断右操作数
|| 在判断左操作数成功时就不会判断右操作数
```

